---
title: "テラスタルを考慮したタイプの組み合わせの優秀さをPythonで計算する"
emoji: "🐡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["python", "python3", "ポケモン"]
published: false
---

# はじめに

来月の18日にポケモン最新作の『ポケットモンスタースカーレット/バイオレット』(以下「ポケモン SV」)が遂に発売されますね。
私はポケモンに向けて18日と週明けの21日に有給を取りました!!!

新作発売が近づくにつれ、様々な情報が解禁され待ち遠しくなる今日この頃です。

ポケモンSVで新しく導入される戦闘システムに「テラスタル」があります。これは全てのポケモンが本来持ってたタイプとは別にテラスタイプを持つことができ、任意のタイミングでテラスタイプに変更できるシステムです.

![バンギラスVSエルレイド](/images/defensive_tera_type/battle_img_01.jpeg)
![ゴーストテラスタルバンギラスVSエルレイド](/images/defensive_tera_type/battle_img_02.jpeg)

今回は今までの2タイプの組み合わせに加えて、テラスタイプを考慮した場合に優秀なタイプの組み合わせをPythonで計算していきたいと思います.

# 計算方法の解説
今回はグラフ理論を用いてテラスタイプを含めたタイプの組み合わせ同士の優劣を計算します。タイプ間の相性の計算方法、及びグラフ理論を用いるに至る経緯は参考元の記事にとても詳しく解説されているのでそちらをご覧ください。

参考
https://qiita.com/masaka_programming/items/503eaa2c1fa776dfdb19

## 2タイプの組み合わせにおける相性の計算

2タイプの複合ダメージ倍率のとりうる値は`0,0.25,0.5,1,2,4`の6段階であり、そのなかで相手に有効なタイプのダメージ倍率の段階の差が相手のポケモンへの有利さと考えることができます。

```python
# タイプと数字の対応配列
types = ["無","ノーマル","ほのお","みず","でんき","くさ","こおり","かくとう","どく",
"じめん","ひこう","エスパー","むし","いわ","ゴースト","ドラゴン","あく","はがね","フェアリー"]

# 1タイプ間の相性行列
M =[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.5, 0, 1, 1, 0.5, 1],
 [1, 1, 0.5, 0.5, 1, 2, 2, 1, 1, 1, 1, 1, 2, 0.5, 1, 0.5, 1, 2, 1],
 [1, 1, 2, 0.5, 1, 0.5, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0.5, 1, 1, 1],
 [1, 1, 1, 2, 0.5, 0.5, 1, 1, 1, 0, 2, 1, 1, 1, 1, 0.5, 1, 1, 1],
 [1, 1, 0.5, 2, 1, 0.5, 1, 1, 0.5, 2, 0.5, 1, 0.5, 2, 1, 0.5, 1, 0.5, 1],
 [1, 1, 0.5, 0.5, 1, 2, 0.5, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 0.5, 1],
 [1, 2, 1, 1, 1, 1, 2, 1, 0.5, 1, 0.5, 0.5, 0.5, 2, 0, 1, 2, 2, 0.5],
 [1, 1, 1, 1, 1, 2, 1, 1, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, 1, 1, 0, 2],
 [1, 1, 2, 1, 2, 0.5, 1, 1, 2, 1, 0, 1, 0.5, 2, 1, 1, 1, 2, 1],
 [1, 1, 1, 1, 0.5, 2, 1, 2, 1, 1, 1, 1, 2, 0.5, 1, 1, 1, 0.5, 1],
 [1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0.5, 1, 1, 1, 1, 0, 0.5, 1],
 [1, 1, 0.5, 1, 1, 2, 1, 0.5, 0.5, 1, 0.5, 2, 1, 1, 0.5, 1, 2, 0.5, 0.5],
 [1, 1, 2, 1, 1, 1, 2, 0.5, 1, 0.5, 2, 1, 2, 1, 1, 1, 1, 0.5, 1],
 [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 0.5, 1, 1],
 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0.5, 0],
 [1, 1, 1, 1, 1, 1, 1, 0.5, 1, 1, 1, 2, 1, 1, 2, 1, 0.5, 1, 0.5],
 [1, 1, 0.5, 0.5, 0.5, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0.5, 2],
 [1, 1, 0.5, 1, 1, 1, 1, 2, 0.5, 1, 1, 1, 1, 1, 1, 2, 2, 0.5, 1]]
```

```python
import math
import numpy as np

# ダメージ倍率
def f(x,yz):
  y,z = yz
  return M[x][y]*M[x][z]

# 複合ダメージ倍率
def g(wx,yz):
  w, x = wx
  y, z = yz
  return max(f(w,(y,z)),f(x,(y,z)))

# タイプの組み合わせ間の有利さ
def h(wx,yz):
  w, x = wx
  y, z = yz
  return int(np.round(math.log2(max(g((w,x),(y,z)),1/8))-math.log2(max(g((y,z),(w,x)),1/8))))
```

画像のバンギラス->エルレイドの対面を想定する場合`(いわ, あく)`と`(かくとう, エスパー)`の相性となるので

```python
print(h((13, 16), (7, 11)))
```

```python
-2
```

バンギラスからエルレイドへの有効な打点はあくタイプの`1`倍、エルレイドからバンギラスへの有効な打点はかくとうタイプの`4`倍です。これは`0,0.25,0.5,1,2,4`のダメージ倍率の段階において4番目と6番目の値なのでバンギラスはエルレイドに対して`-2`の有利さであると計算できていることがわかります。

## テラスタルを考慮する

まずテラスタルの仕様を仮定します。

1. テラスタイプと技のタイプが一致した場合の補正倍率は1.5倍である
2. テラスタイプと元のタイプが一致した場合のそのタイプの補正倍率は2倍となる
3. テラスタルを使用後は防御時に計算されるタイプは、テラスタイプの単タイプとなる

:::message alert
この仕様は今回の検証のために仮で使用するものなので、実際のものとは異なる可能性があります。
:::

> テラスタイプと技のタイプが一致した場合の補正倍率は1.5倍である

こちらの仕様を考慮し、関数を修正します。
複合ダメージ倍率の計算において、、テラスタイプも考慮する必要があるので,**複合ダメージ倍率**$g((w,x,t),(y,z))$とします。
w,x,tについて**ダメージ倍率**$f(x,(y,z))$の計算において最大のものをとるので

$$
max(f(w,(y,z)),f(x,(y,z)),f(t,(y,z)))
$$

が複合ダメージ倍率の計算結果となります。

```diff python
- def g(wx,yz):
-   w, x = wx
+ def g(wxt,yz):
+   w, x, t = wxt
   y, z = yz
-   return max(f(w,(y,z)),f(x,(y,z)))
+   return max(f(w,(y,z)),f(x,(y,z)),f(t,(y,z)))

- def h(wx,yz):
-  w, x = wx
-  y, z = yz
-  return int(np.round(math.log2(max(g((w,x),(y,z)),1/8))-math.log2(max(g((y,z),(w,x)),1/8))))
+ def h(wxt,yzu):
+  w, x, t = wxt
+  y, z, u = yzu
+  return int(np.round(math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))))
```

> テラスタイプと元のタイプが一致した場合のそのタイプの補正倍率は2倍となる

次にこちらを考慮します。

通常のポケモンのタイプと技のタイプの一致時の補正倍率が1.5倍でこれが2倍になることから、$2 / 1.5 = 4 / 3$をテラスタイプと元のタイプの重複時に補正を行います。
**ダメージ倍率**$f((x,t),(y,z))$においてxとtが一致した場合に$4 / 3$の補正値を掛けます。
またテラスタイプで攻撃する際は補正値は無いので**関数f**に$(t, 0)$のタイプを与えます

```diff python
- def f(x,yz):
+ def f(xt,yz):
+   x,t = xt
   y,z = yz
+   m = 4 / 3 if x == t else 1
-   return M[x][y]*M[x][z]
+   return M[x][y]*M[x][z]*m

 def g(wxt,yz):
   w, x, t = wxt
   y, z = yz
-   return max(f(w,(y,z)),f(x,(y,z)),f(t,(y,z)))
+   return max(f((w,t),(y,z)),f((x,t),(y,z)),f((t,0),(y,z)))
```

またこの影響で**タイプの組み合わせ間の有利さ**$h((w,x,t),(y,z,u))$を整数で表せていたものを小数を含めて表現します。

```diff python
 def h(wxt,yzu):
  w, x, t = wxt
  y, z, u = yzu
-  return int(np.round(math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))))
+  return math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))
```

> テラスタルを使用後は防御時に計算されるタイプは、テラスタイプの単タイプとなる

最後に防御時はテラスタイプの単タイプで計算するようにします。
$(タイプ1, タイプ2, テラスタイプ) = (y, z, u)$とするとき、テラスタイプが与えられた時に$関数f$に与える防御側のタイプに$(u, 0)$を与えます。

```diff python
- def g(wxt,yz):
+ def g(wxt,yzu):
   w, x, t = wxt
-   y, z = yz
+   y, z, u = yzu
+   if u != 0:
+     y = u
+     z = 0
   return max(f((w,t),(y,z)),f((x,t),(y,z)),f((t,0),(y,z)))

 def h(wxt,yzu):
  w, x, t = wxt
  y, z, u = yzu
-  return math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))
+  return math.log2(max(g((w,x,t),(y,z,u)),1/8))-math.log2(max(g((y,z,u),(w,x,t)),1/8))
```

それではこれらの関数f,g,hを用いてゴーストテラスタルバンギラスとエルレイドの有利さを計算します.

```python
print(h((13, 16, 14), (7, 11, 0)))
```

```python
1
```

バンギラスからエルレイドへの有効なタイプはエスパータイプの弱点をつけるテラスタイプのゴーストなので倍率は2倍。
それに対してエルレイドからテラスタルを使いゴーストタイプになったバンギラスに対して有効なタイプはエスパータイプなので倍率は1倍。

$$
\log_2 2 - \log_2 1 = 1
$$

なので正しく計算できています。
