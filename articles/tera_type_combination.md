---
title: "テラスタルを考慮したタイプの組み合わせの優秀さをPythonで計算する"
emoji: "🏖️"
type: "tech"
topics:
  - "python"
  - "python3"
  - "ポケモン"
published: true
published_at: "2022-11-17 18:00"
---

# はじめに

18日にポケモン最新作の『ポケットモンスタースカーレット/バイオレット』(以下「ポケモン SV」)が遂に発売されますね。
私はポケモンに向けて18日と週明けの21日に有給を取りました!!!

ポケモンSVで新しく導入される戦闘システムに「テラスタル」があります。これは全てのポケモンが本来持ってたタイプとは別にテラスタイプを持つことができ、任意のタイミングでテラスタイプに変更できるシステムです.

![バンギラスVSエルレイド](/images/defensive_tera_type/battle_img_01.jpeg)
![ゴーストテラスタルバンギラスVSエルレイド](/images/defensive_tera_type/battle_img_02.jpeg)

今回は今までの2タイプの組み合わせに加えて、テラスタイプを考慮した場合に優秀なタイプの組み合わせをPythonで計算していきたいと思います.

# 計算方法の解説

今回はグラフ理論を用いてテラスタイプを含めたタイプの組み合わせ同士の優劣を計算します。2タイプ間の相性の計算方法、及びグラフ理論を用いるに至る経緯は今回参考にした記事にとても詳しく解説されているのでそちらをご覧ください。

参考
https://qiita.com/masaka_programming/items/503eaa2c1fa776dfdb19

## 2タイプの組み合わせにおける相性の計算

2タイプの複合ダメージ倍率のとりうる値は`0,0.25,0.5,1,2,4`の6段階であり、そのなかで相手に有効なタイプのダメージ倍率の段階の差が相手のポケモンへの有利さと考えることができます。

```python
# タイプと数字の対応配列
types = ["無","ノーマル","ほのお","みず","でんき","くさ","こおり","かくとう","どく",
"じめん","ひこう","エスパー","むし","いわ","ゴースト","ドラゴン","あく","はがね","フェアリー"]

# 1タイプ間の相性行列
M =[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.5, 0, 1, 1, 0.5, 1],
 [1, 1, 0.5, 0.5, 1, 2, 2, 1, 1, 1, 1, 1, 2, 0.5, 1, 0.5, 1, 2, 1],
 [1, 1, 2, 0.5, 1, 0.5, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0.5, 1, 1, 1],
 [1, 1, 1, 2, 0.5, 0.5, 1, 1, 1, 0, 2, 1, 1, 1, 1, 0.5, 1, 1, 1],
 [1, 1, 0.5, 2, 1, 0.5, 1, 1, 0.5, 2, 0.5, 1, 0.5, 2, 1, 0.5, 1, 0.5, 1],
 [1, 1, 0.5, 0.5, 1, 2, 0.5, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 0.5, 1],
 [1, 2, 1, 1, 1, 1, 2, 1, 0.5, 1, 0.5, 0.5, 0.5, 2, 0, 1, 2, 2, 0.5],
 [1, 1, 1, 1, 1, 2, 1, 1, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, 1, 1, 0, 2],
 [1, 1, 2, 1, 2, 0.5, 1, 1, 2, 1, 0, 1, 0.5, 2, 1, 1, 1, 2, 1],
 [1, 1, 1, 1, 0.5, 2, 1, 2, 1, 1, 1, 1, 2, 0.5, 1, 1, 1, 0.5, 1],
 [1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0.5, 1, 1, 1, 1, 0, 0.5, 1],
 [1, 1, 0.5, 1, 1, 2, 1, 0.5, 0.5, 1, 0.5, 2, 1, 1, 0.5, 1, 2, 0.5, 0.5],
 [1, 1, 2, 1, 1, 1, 2, 0.5, 1, 0.5, 2, 1, 2, 1, 1, 1, 1, 0.5, 1],
 [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 0.5, 1, 1],
 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0.5, 0],
 [1, 1, 1, 1, 1, 1, 1, 0.5, 1, 1, 1, 2, 1, 1, 2, 1, 0.5, 1, 0.5],
 [1, 1, 0.5, 0.5, 0.5, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0.5, 2],
 [1, 1, 0.5, 1, 1, 1, 1, 2, 0.5, 1, 1, 1, 1, 1, 1, 2, 2, 0.5, 1]]
```

```python
import math
import numpy as np

# ダメージ倍率
def f(x,yz):
  y,z = yz
  return M[x][y]*M[x][z]

# 複合ダメージ倍率
def g(wx,yz):
  w, x = wx
  y, z = yz
  return max(f(w,(y,z)),f(x,(y,z)))

# タイプの組み合わせ間の有利さ
def h(wx,yz):
  w, x = wx
  y, z = yz
  return int(np.round(math.log2(max(g((w,x),(y,z)),1/8))-math.log2(max(g((y,z),(w,x)),1/8))))
```

画像のバンギラス->エルレイドの対面を想定する場合`(いわ, あく)`と`(かくとう, エスパー)`の相性となるので

```python
print(h((13, 16), (7, 11)))
```

```python
-2
```

バンギラスからエルレイドへの有効な打点はあくタイプの`1`倍、エルレイドからバンギラスへの有効な打点はかくとうタイプの`4`倍です。これは`0,0.25,0.5,1,2,4`のダメージ倍率の段階において4番目と6番目の値なのでバンギラスはエルレイドに対して`-2`の有利さであると計算できていることがわかります。

## テラスタルを考慮する

まずテラスタルの仕様を仮定します。

1. テラスタイプと技のタイプが一致した場合の補正倍率は1.5倍である
2. テラスタイプと元のタイプが一致した場合のそのタイプの補正倍率は2倍となる
3. テラスタルを使用後は防御時に計算されるタイプは、テラスタイプの単タイプとなる

:::message alert
この仕様は今回の検証のために仮で使用するものなので、実際のものとは異なる可能性があります。
:::

攻撃側のポケモンのタイプは$(タイプ1, タイプ2, テラスタイプ) = (w, x, t)$、防御側のポケモンのタイプは$(タイプ1, タイプ2, テラスタイプ) = (y, z, u)$とします。

> テラスタイプと技のタイプが一致した場合の補正倍率は1.5倍である

こちらの仕様を考慮し、関数を修正します。
複合ダメージ倍率の計算において、、テラスタイプも考慮する必要があるので,**複合ダメージ倍率**$g((w,x,t),(y,z))$とします。
w,x,tについて**ダメージ倍率**$f(x,(y,z))$の計算において最大のものをとるので

$$
max(f(w,(y,z)),f(x,(y,z)),f(t,(y,z)))
$$

が複合ダメージ倍率の計算結果となります。

```diff python
- def g(wx,yz):
-   w, x = wx
+ def g(wxt,yz):
+   w, x, t = wxt
   y, z = yz
-   return max(f(w,(y,z)),f(x,(y,z)))
+   return max(f(w,(y,z)),f(x,(y,z)),f(t,(y,z)))

- def h(wx,yz):
-  w, x = wx
-  y, z = yz
-  return int(np.round(math.log2(max(g((w,x),(y,z)),1/8))-math.log2(max(g((y,z),(w,x)),1/8))))
+ def h(wxt,yzu):
+  w, x, t = wxt
+  y, z, u = yzu
+  return int(np.round(math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))))
```

> テラスタイプと元のタイプが一致した場合のそのタイプの補正倍率は2倍となる

次にこちらを考慮します。

通常のポケモンのタイプと技のタイプの一致時の補正倍率が1.5倍でこれが2倍になることから、$2 / 1.5 = 4 / 3$をテラスタイプと元のタイプの重複時に補正を行います。
**ダメージ倍率**$f((x,t),(y,z))$においてxとtが一致した場合に$4 / 3$の補正値を掛けます。
またテラスタイプで攻撃する際は補正値は無いので**関数f**に$(t, 0)$のタイプを与えます

```diff python
- def f(x,yz):
+ def f(xt,yz):
+   x,t = xt
   y,z = yz
+   m = 4 / 3 if x == t else 1
-   return M[x][y]*M[x][z]
+   return M[x][y]*M[x][z]*m

 def g(wxt,yz):
   w, x, t = wxt
   y, z = yz
-   return max(f(w,(y,z)),f(x,(y,z)),f(t,(y,z)))
+   return max(f((w,t),(y,z)),f((x,t),(y,z)),f((t,0),(y,z)))
```

またこの影響で**タイプの組み合わせ間の有利さ**$h((w,x,t),(y,z,u))$を整数で表せていたものを小数を含めて表現します。

```diff python
 def h(wxt,yzu):
  w, x, t = wxt
  y, z, u = yzu
-  return int(np.round(math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))))
+  return math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))
```

> テラスタルを使用後は防御時に計算されるタイプは、テラスタイプの単タイプとなる

最後に防御時はテラスタイプの単タイプで計算するようにします。
テラスタイプが与えられた時に$関数f$に与える防御側のタイプに$(u, 0)$を与えます。

```diff python
- def g(wxt,yz):
+ def g(wxt,yzu):
   w, x, t = wxt
-   y, z = yz
+   y, z, u = yzu
+   if u != 0:
+     y = u
+     z = 0
   return max(f((w,t),(y,z)),f((x,t),(y,z)),f((t,0),(y,z)))

 def h(wxt,yzu):
  w, x, t = wxt
  y, z, u = yzu
-  return math.log2(max(g((w,x,t),(y,z)),1/8))-math.log2(max(g((y,z,u),(w,x)),1/8))
+  return math.log2(max(g((w,x,t),(y,z,u)),1/8))-math.log2(max(g((y,z,u),(w,x,t)),1/8))
```

それではこれらの関数f,g,hを用いてゴーストテラスタルバンギラスとエルレイドの有利さを計算します.

```python
print(h((13, 16, 14), (7, 11, 0)))
```

```python
1
```

バンギラスからエルレイドへの有効なタイプはエスパータイプの弱点をつけるテラスタイプのゴーストなので倍率は2倍。
それに対してエルレイドからテラスタルを使いゴーストタイプになったバンギラスに対して有効なタイプはエスパータイプなので倍率は1倍。

$$
\log_2 2 - \log_2 1 = 1
$$

なので正しく計算できています。

# 強いテラスタイプの組み合わせを計算する

ここまでで作成した関数を用いて強いテラスタイプの組み合わせを計算します。18タイプと無タイプを合わせた19から2つ選ぶ組み合わせに合わせて、テラスタイプも同様に19から1つ選ぶことになります。

$$
{}_{19} \mathrm{C}_2 × {}_{19} \mathrm{C}_1 = 171 × 19 = 3249
$$

このタイプの組み合わせについて計算を行います。

```python
# タイプの全ての組み合わせの計算
result = []
for w in range(18):
  for x in range(w+1,19):
    for t in range(0, 19):
      score = 0
      for y in range(18):
        for z in range(y+1,19):
          for u in range(0, 19):
            score += h((w,x,t),(y,z,u))
      result.append(((w,x,t),score))
result.sort(key=lambda x:x[1], reverse=True)

# 結果の出力
for i in range(10):
  wxt,score =  result[i]
  w,x,t = wxt
  print(types[x], types[w], types[t], score)
```

```python
はがね じめん はがね 1634.8238609834466
フェアリー じめん フェアリー 1463.0133359935503
じめん こおり はがね 1402.031600161537
こおり でんき でんき 1384.6839983846464
はがね かくとう はがね 1367.342673602412
かくとう でんき でんき 1356.6765615084273
じめん でんき でんき 1342.733673775493
ゴースト かくとう ゴースト 1287.7486734870492
じめん ほのお でんき 1268.0150626911054
じめん こおり でんき 1268.0150626911054
```

以降、この計算方法によって求められるスコアを総合スコアを呼びます。1位は2タイプの組み合わせでも優秀な、はがね+じめんの組み合わせに防御面で優秀なはがねのテラスタイプと合わせたものが総合スコアにおいて優秀という結果が求まりました。

上位10つの組み合わせのうち

```text
タイプ一致テラスタイプ: 7つ
タイプ不一致テラスタイプ: 3つ
```

となっていることから、タイプの噛み合わせがかなり良い場合以外はタイプ一致テラスタイプの高火力を利用するのが有効だと分かります。

また目立つのはじめん+でんきテラスタイプの組み合わせです。じめんは攻撃面において優秀なタイプであり、じめんの対して有利なひこうタイプやみずタイプに対して有利であり且つじめんタイプの弱点を消すことができるでんきタイプが評価されたと分かります。

# PageRankの適用

## PageRankとは

PageRankとはGoogleの検索エンジンにおいてサイトの重要度を決定するためのアルゴリズムです。Googleの検索エンジンにおいては被リンクの数が多ければ多いほど評価されるようになっていますが、それに加えて被リンク先の重要度も評価します。

https://ja.wikipedia.org/wiki/%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%A9%E3%83%B3%E3%82%AF

## ポケモンのタイプに適用する

ここまで計算したポケモンのタイプの組み合わせの強さは相性の計算結果の合計であり、特定の組み合わせだからといってどんなタイプに対しても有効なわけではありません。
先ほど1位になった`はがね, じめん, はがね`の組み合わせに対しても有利なタイプは存在しておりそのようなタイプは大きく評価するべきです。
PageRankのアルゴリズムを使用することでそのようなメタ的な強さを評価することができます。

具体的に考えます。
ポケモンのタイプにおいてくさタイプは弱いタイプとして知られています。これは計算結果から見ても明らかです。

```python
# スコアの計算
result = []
for x in range(1, 19):
  score = 0
  for y in range(1, 19):
    score += math.log2(max(M[x][y], 1/8)) - math.log2(max(M[y][x], 1/8))
  result.append((x, score))

result.sort(key=lambda x:x[1], reverse=True)

# 結果の出力
for el in result:
  i, score = el
  print(types[i], score)
```

```python
はがね 9.0
ゴースト 4.0
フェアリー 4.0
ほのお 3.0
ひこう 3.0
みず 2.0
じめん 2.0
あく 1.0
いわ 0.0
でんき -2.0
どく -2.0
ドラゴン -2.0
ノーマル -3.0
こおり -3.0
かくとう -3.0
エスパー -4.0
むし -4.0
くさ -5.0
```

ではくさタイプのポケモンは全く使われないのかというとそうではありません。
ナットレイやゴリランダーといったポケモンはくさタイプでありながら一定の使用率があります。

![シーズン20ポケモン使用率ランキング](/images/defensive_tera_type/pokemon_ranking.png)
*シーズン20ポケモン使用率ランキング*

PageRankの有効性を説明するためにタイプを限定した環境について考察します。
タイプが「ほのお」「みず」「でんき」「くさ」「じめん」「はがね」の環境を考えます。

```python
example = [
    2, # ほのお
    3, # みず
    4, # でんき
    5, # くさ
    9, # じめん
    17, # はがね
]

# スコアの計算
result = []
for i in range(len(example)):
  score = 0
  x = example[i]
  for j in range(i + 1, len(example)):
    y = example[j]
    score += math.log2(max(M[x][y], 1/8)) - math.log2(max(M[y][x], 1/8))
  result.append((x, score))

result.sort(key=lambda x:x[1], reverse=True)

# 結果の出力
for el in result:
  i, score = el
  print(types[i], score)
```

```python
じめん 4.0
ほのお 2.0
みず 1.0
でんき 0
はがね -1.0
くさ -2.0
```

この環境においてもくさタイプは攻撃面と防御面の総合スコアは優秀とは言えません。しかしこの環境においてPageRankを用いたスコアを計算します。

```python
from scipy.sparse.linalg import eigs

# タイプ間の相性行列の作成
A = [[0 for _ in range(len(example))] for _ in range(len(example))]
for i in range(len(example)):
  x = example[i]
  for j in range(len(example)):
    y = example[j]
    score = math.log2(max(M[x][y], 1/8)) - math.log2(max(M[y][x], 1/8))
    if score < 0:
      A[i][j] = -score

# PageRankの適用
S = np.array(A)
T = 1/len(example)*np.ones((len(example),len(example)))
G = 0.85*S.T+0.15*T
value, vector = eigs(G, 1)
vector = np.abs(vector.real)

result = [(index, score[0]) for index, score in enumerate(vector)]
result.sort(key=lambda x:x[1],reverse=True)

# 結果の出力
for k in result:
  print(types[example[k[0]]], k[1])
```

```python
くさ 0.5775495515901172
ほのお 0.4528530594249737
みず 0.451553587787844
じめん 0.4285430909570378
でんき 0.2001510836393262
はがね 0.1837126623137694
```

この環境においてはPageRankで評価した場合にくさタイプは最も優秀と評価されました。
先ほどでは`じめん, ほのお, みず, でんき, はがね, くさ`の順で総合スコアにおいて優秀とされましたが、くさタイプは上位のじめんとみずに対して有効であることを大きく評価し、下位のはがねタイプに不利なことは低く評価された結果だということが分かります。

以降この計算方法によって求めたスコアをPageRankスコアと呼びます。

## PageRankのテラスタイプへの適用

PageRankスコアをテラスタイプも含めて計算します。

```python
from scipy.sparse.linalg import eigs

# タイプの組み合わせと数字の対応を辞書型で作成
d = {}
d_inv = {}
k = 0
for i in range(18):
  for j in range(i+1,19):
    for l in range(19):
      d[(i,j,l)] = k
      d_inv[k] = (i,j,l)
      k += 1

# タイプ間の相性行列の作成
A = [[0 for _ in range(3249)] for _ in range(3249)]
for w in range(18):
  for x in range(w+1,19):
    for t in range(19):
      k = d[(w,x,t)] 
      for y in range(18):
        for z in range(y+1,19):
          for u in range(19):
            l = d[(y,z,u)]
            if h((w,x,t),(y,z,u)) < 0:
              A[k][l] = -h((w,x,t),(y,z,u))

# PageRankの適用
A = np.array(A,dtype=np.float)
S = np.zeros((3249,3249))
for i in range(3249):
  S[i] = A[i]/sum(A[i])
T = (1/3249)*np.ones((3249,3249))
G = 0.85*S.T+0.15*T
value, vector = eigs(G, 1)
vector = np.abs(vector.real)
result = []
for i in range(3249):
  w,x,t = d_inv[i]
  result.append(((w,x,t),vector[i][0]))
result.sort(key=lambda x:x[1],reverse=True)

# 上位10位までのタイプの組み合わせの出力
for i in range(10):
  wxt,score =  result[i]
  w,x,t = wxt
  print(types[w],types[x],types[t],score)
```

```python
でんき じめん でんき 0.03574379239637863
こおり じめん じめん 0.035394307172703546
じめん いわ じめん 0.03414661370676045
じめん フェアリー じめん 0.034138156387748975
かくとう じめん じめん 0.03381328758251239
じめん ひこう じめん 0.033709671007023545
じめん ゴースト じめん 0.03366905167728781
じめん あく じめん 0.03365716746888824
じめん はがね はがね 0.03339445425251873
じめん むし じめん 0.03278889380226626
```

PageRankスコアの計算結果、先ほども優秀とされたでんき+じめんのタイプの組み合わせにでんきのテラスタイプが優秀であるという計算結果が求まりました。
また総合スコアにおいて優秀とされたはがねとでんきのテラスタイプに対して有効なじめんが目立つことからPageRankを適用させた意義は出ているように感じます。

調べてみるとでんき+じめんタイプは一匹だけいるようですね。マッギョっていうんですけど、、、
ポケモンの強さを決定する要素はタイプ以外にも様々な要素の組み合わせで決定されますが、新しく登場するポケモンにでんき+じめんタイプのポケモンがいれば注目する必要がありそうです。

じめんタイプは攻撃面でかなり優秀なタイプであり、さらにテラスタイプで強化していくのが強いと言えそうです。
シングルバトルにおいてもダブルバトルにおいてもテラスタイプ一致のじしんを高い素早さで使うことができるポケモンが猛威を震いそうな予感がしますね。
現在内定しているポケモンには居なさそうですが、ガブリアスやランドロスのようなポケモンが環境の中心に来るかもしれません。

# 感想

長い記事でしたがお読みくださりありがとうございました。
ポケモンSVの発売をとても長い間待ち侘びてましたが、今週末まで迫ってきて実感が湧いてきている今日この頃です。

今後やりたいこととして今回の分析においてでんきテラスタルがある程度優秀であるとなっていましたが、でんきタイプを単体で見るとそこまで優秀ではなくあんまり納得できていない部分もあります。しかしでんきタイプのポケモンはあらゆる世代において常に使用率上位にいたことから感覚では納得できる面があり、他の手法を用いて分析したいところです。

また個人としてもこれから全てのポケモンについての強さを決定づける要素をタイプ以外でも様々な手法から分析していきたいと思っています。

https://twitter.com/pokepro_ch
